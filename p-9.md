
# üõ†Ô∏è Pr√°ctica: Desarrollo de un Sistema de Monitoreo Local y Remoto con Arduino, ESP32 y MySQL

## ‚úÖ Parte 1: Estructura inicial de la aplicaci√≥n

---

### üéØ Objetivo

* Crear la **ventana principal** con dos pesta√±as:

  * üñ•Ô∏è **Pesta√±a 1: Monitor Local (Arduino + Serial)**
  * üåê **Pesta√±a 2: Monitor Remoto (ESP32 + HTTP)**

* Incluir:

  * Men√∫ superior con Archivo y Opciones.
  * Opci√≥n de cambiar entre **Modo oscuro** y **Modo claro**.
  * Preparar espacio en ambas pesta√±as para futuras funciones.

---

## üìÑ C√≥digo COMPLETO inicial:

```python
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, colorchooser

# ================================================
# Configuraci√≥n inicial de la ventana principal
# ================================================

ventana = tk.Tk()
ventana.title("Monitor Local y Remoto - Arduino & ESP32")
ventana.geometry("800x600")

# Variable global para saber si el modo oscuro est√° activo
modo_oscuro_activo = False

# ================================================
# Men√∫ superior
# ================================================

def aplicar_modo_oscuro():
    global modo_oscuro_activo
    modo_oscuro_activo = True
    ventana.config(bg="#2b2b2b")
    style.theme_use("clam")
    style.configure("TNotebook", background="#2b2b2b")
    style.configure("TNotebook.Tab", background="#3c3c3c", foreground="white")
    aplicar_estilos_pesta√±as("#2b2b2b", "white")

def aplicar_modo_claro():
    global modo_oscuro_activo
    modo_oscuro_activo = False
    ventana.config(bg="SystemButtonFace")
    style.theme_use("default")
    aplicar_estilos_pesta√±as("SystemButtonFace", "black")

def aplicar_estilos_pesta√±as(bg_color, fg_color):
    # Local
    frame_local.config(bg=bg_color)
    etiqueta_local_titulo.config(bg=bg_color, fg=fg_color)
    # Remoto
    frame_remoto.config(bg=bg_color)
    etiqueta_remoto_titulo.config(bg=bg_color, fg=fg_color)

def salir():
    if messagebox.askokcancel("Salir", "¬øSeguro que quieres salir?"):
        ventana.destroy()

menu_barra = tk.Menu(ventana)
ventana.config(menu=menu_barra)

# Men√∫ Archivo
menu_archivo = tk.Menu(menu_barra, tearoff=0)
menu_archivo.add_command(label="Salir", command=salir)
menu_barra.add_cascade(label="Archivo", menu=menu_archivo)

# Men√∫ Opciones
menu_opciones = tk.Menu(menu_barra, tearoff=0)
menu_opciones.add_command(label="Modo oscuro", command=aplicar_modo_oscuro)
menu_opciones.add_command(label="Modo claro", command=aplicar_modo_claro)
menu_barra.add_cascade(label="Opciones", menu=menu_opciones)

# ================================================
# Crear pesta√±as (Notebook)
# ================================================

style = ttk.Style()
notebook = ttk.Notebook(ventana)
notebook.pack(fill="both", expand=True)

# ================================================
# PESTA√ëA 1: Monitor Local (Arduino)
# ================================================

frame_local = tk.Frame(notebook)
notebook.add(frame_local, text="Monitor Local (Arduino)")

# T√≠tulo de la pesta√±a
etiqueta_local_titulo = tk.Label(frame_local, text="Monitoreo Local - Arduino (Serial)", font=("Arial", 16))
etiqueta_local_titulo.pack(pady=10)

# Aqu√≠ comenzamos a dejar espacio para los elementos que agregaremos despu√©s:
# ‚ñ∏ ComboBox para puertos
# ‚ñ∏ Botones de Conectar/Desconectar
# ‚ñ∏ √Årea de log con Scroll
# ‚ñ∏ Botones para enviar comandos
# ‚ñ∏ Barra de progreso / gr√°ficas (se agregar√°n despu√©s)

frame_local_conexion = tk.Frame(frame_local)
frame_local_conexion.pack(pady=5)

tk.Label(frame_local_conexion, text="Puerto Serial:").grid(row=0, column=0, padx=5)
combo_puertos = ttk.Combobox(frame_local_conexion)
combo_puertos.grid(row=0, column=1, padx=5)

boton_refrescar_puertos = tk.Button(frame_local_conexion, text="Refrescar", command=lambda: print("Refrescar puertos (lo haremos despu√©s)"))
boton_refrescar_puertos.grid(row=0, column=2, padx=5)

boton_conectar_local = tk.Button(frame_local_conexion, text="Conectar", command=lambda: print("Conectar Arduino (pendiente)"))
boton_conectar_local.grid(row=0, column=3, padx=5)

boton_desconectar_local = tk.Button(frame_local_conexion, text="Desconectar", state="disabled", command=lambda: print("Desconectar Arduino (pendiente)"))
boton_desconectar_local.grid(row=0, column=4, padx=5)

# Caja de texto para mostrar datos
frame_local_texto = tk.Frame(frame_local)
frame_local_texto.pack(fill="both", expand=True, padx=10, pady=10)

caja_texto_local = tk.Text(frame_local_texto, wrap="none")
caja_texto_local.pack(side="left", fill="both", expand=True)

scroll_texto_local = tk.Scrollbar(frame_local_texto, command=caja_texto_local.yview)
scroll_texto_local.pack(side="right", fill="y")
caja_texto_local.config(yscrollcommand=scroll_texto_local.set)

# ================================================
# PESTA√ëA 2: Monitor Remoto (ESP32)
# ================================================

frame_remoto = tk.Frame(notebook)
notebook.add(frame_remoto, text="Monitor Remoto (ESP32)")

etiqueta_remoto_titulo = tk.Label(frame_remoto, text="Monitoreo Remoto - ESP32 (HTTP)", font=("Arial", 16))
etiqueta_remoto_titulo.pack(pady=10)

# √Årea para colocar los controles y visualizaci√≥n remota
frame_remoto_conexion = tk.Frame(frame_remoto)
frame_remoto_conexion.pack(pady=5)

tk.Label(frame_remoto_conexion, text="URL del ESP32:").grid(row=0, column=0, padx=5)
entrada_url_esp32 = tk.Entry(frame_remoto_conexion, width=40)
entrada_url_esp32.grid(row=0, column=1, padx=5)

boton_conectar_remoto = tk.Button(frame_remoto_conexion, text="Iniciar monitoreo", command=lambda: print("Iniciar monitoreo remoto (pendiente)"))
boton_conectar_remoto.grid(row=0, column=2, padx=5)

# Caja de texto para datos remotos
frame_remoto_texto = tk.Frame(frame_remoto)
frame_remoto_texto.pack(fill="both", expand=True, padx=10, pady=10)

caja_texto_remoto = tk.Text(frame_remoto_texto, wrap="none")
caja_texto_remoto.pack(side="left", fill="both", expand=True)

scroll_texto_remoto = tk.Scrollbar(frame_remoto_texto, command=caja_texto_remoto.yview)
scroll_texto_remoto.pack(side="right", fill="y")
caja_texto_remoto.config(yscrollcommand=scroll_texto_remoto.set)

# ================================================
# Iniciar ventana
# ================================================

ventana.mainloop()
```

---

## ‚úÖ Hasta este punto, revisar que se tiene: 

* ‚úÖ **Ventana principal completa**.
* ‚úÖ **Dos pesta√±as listas: Local y Remoto.**
* ‚úÖ **Men√∫ superior:** Archivo y Opciones.
* ‚úÖ **Modo oscuro y modo claro funcionales.**
* ‚úÖ **ComboBox de puertos, bot√≥n refrescar, conectar y desconectar (Local).**
* ‚úÖ **Entrada de URL y bot√≥n de monitoreo (Remoto).**
* ‚úÖ **Caja de texto con scroll en ambas pesta√±as para mostrar datos recibidos.**
* ‚úÖ **Puntos marcados y comentados para saber qu√© l√≥gica agregar despu√©s.**

---


## ‚úÖ Parte 2: Implementaci√≥n del monitoreo local (Arduino + Serial + MySQL)

---

### üéØ Objetivos de esta parte:

1Ô∏è‚É£ Detectar autom√°ticamente los **puertos seriales disponibles** y cargarlos en la lista desplegable.

2Ô∏è‚É£ Conectar al Arduino por Serial y:

* Leer datos peri√≥dicamente.
* Mostrar los datos en la caja de texto (log).
* Usar auto-scroll para que siempre se vea lo √∫ltimo.

3Ô∏è‚É£ **Guardar los datos recibidos en la base de datos MySQL**.

4Ô∏è‚É£ Enviar comandos simples al Arduino (desde la GUI).

---

## üóÇÔ∏è Estructura general

* ‚úÖ **Funcionalidad completa:** Detecci√≥n de puertos, conexi√≥n, lectura continua y guardado en MySQL.
* ‚úÖ **Puntos claves** para que entiendan c√≥mo extenderlo.
* ‚úÖ **C√≥digo listo** y **comentarios** para que solo hagan mejoras peque√±as o adaptaciones seg√∫n sus sensores.

---

## üìÑ C√≥digo COMPLETO de la Parte 2:

```python
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, colorchooser
import serial
import serial.tools.list_ports
import mysql.connector
from datetime import datetime

# ================================================
# Variables globales
# ================================================
ser = None  # Puerto serial
modo_oscuro_activo = False

# ================================================
# Funciones para la conexi√≥n con Arduino
# ================================================

def detectar_puertos():
    """Detecta puertos disponibles y los carga en la lista desplegable."""
    puertos = serial.tools.list_ports.comports()
    lista = [p.device for p in puertos]
    combo_puertos['values'] = lista
    if lista:
        combo_puertos.current(0)
    else:
        combo_puertos.set('')

def conectar_serial():
    """Establece conexi√≥n con el puerto seleccionado."""
    global ser
    puerto = combo_puertos.get()
    if not puerto:
        messagebox.showerror("Error", "Selecciona un puerto para conectar.")
        return

    try:
        ser = serial.Serial(puerto, 9600, timeout=1)
        boton_conectar_local.config(state="disabled")
        boton_desconectar_local.config(state="normal")
        caja_texto_local.insert("end", f"[{datetime.now()}] Conectado a {puerto}\n")
        leer_serial()
    except Exception as e:
        messagebox.showerror("Error de conexi√≥n", str(e))

def desconectar_serial():
    """Cierra la conexi√≥n serial."""
    global ser
    if ser and ser.is_open:
        ser.close()
    boton_conectar_local.config(state="normal")
    boton_desconectar_local.config(state="disabled")
    caja_texto_local.insert("end", f"[{datetime.now()}] Desconectado.\n")

def leer_serial():
    """Lee datos continuamente del puerto serial y los guarda en la BD."""
    global ser
    if ser and ser.is_open:
        try:
            if ser.in_waiting:
                linea = ser.readline().decode('utf-8', errors='ignore').strip()
                if linea:
                    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    texto = f"[{timestamp}] {linea}"
                    caja_texto_local.insert("end", texto + "\n")
                    caja_texto_local.see("end")
                    guardar_en_bd(timestamp, linea)
        except Exception as e:
            messagebox.showerror("Error de lectura", str(e))
            desconectar_serial()
    ventana.after(100, leer_serial)

def enviar_comando():
    """Env√≠a el texto escrito al Arduino."""
    global ser
    texto = entrada_envio.get()
    if ser and ser.is_open:
        ser.write((texto + "\n").encode('utf-8'))
        caja_texto_local.insert("end", f"[{datetime.now()}] >> {texto}\n")
        caja_texto_local.see("end")
        entrada_envio.delete(0, "end")
    else:
        messagebox.showwarning("Desconectado", "No hay conexi√≥n activa.")

# ================================================
# Funci√≥n para guardar en MySQL
# ================================================

def guardar_en_bd(timestamp, dato):
    """Guarda cada dato recibido en la base de datos."""
    try:
        conexion = mysql.connector.connect(
            host="localhost",      # Cambiar si la BD est√° en otro lugar
            user="root",           # Cambiar seg√∫n tus credenciales
            password="",           # Cambiar seg√∫n tus credenciales
            database="monitor"     # Nombre de la base de datos (crear antes)
        )
        cursor = conexion.cursor()
        sql = "INSERT INTO lecturas_locales (fecha_hora, dato) VALUES (%s, %s)"
        valores = (timestamp, dato)
        cursor.execute(sql, valores)
        conexion.commit()
        cursor.close()
        conexion.close()
    except mysql.connector.Error as e:
        print(f"Error guardando en BD: {e}")

# ================================================
# GUI (estructura creada en la Parte 1)
# ================================================

ventana = tk.Tk()
ventana.title("Monitor Local y Remoto - Arduino & ESP32")
ventana.geometry("800x600")

style = ttk.Style()
notebook = ttk.Notebook(ventana)
notebook.pack(fill="both", expand=True)

# ----------------------------------------
# PESTA√ëA 1: Monitor Local (Arduino)
# ----------------------------------------

frame_local = tk.Frame(notebook)
notebook.add(frame_local, text="Monitor Local (Arduino)")

etiqueta_local_titulo = tk.Label(frame_local, text="Monitoreo Local - Arduino (Serial)", font=("Arial", 16))
etiqueta_local_titulo.pack(pady=10)

frame_local_conexion = tk.Frame(frame_local)
frame_local_conexion.pack(pady=5)

tk.Label(frame_local_conexion, text="Puerto Serial:").grid(row=0, column=0, padx=5)
combo_puertos = ttk.Combobox(frame_local_conexion)
combo_puertos.grid(row=0, column=1, padx=5)

boton_refrescar_puertos = tk.Button(frame_local_conexion, text="Refrescar", command=detectar_puertos)
boton_refrescar_puertos.grid(row=0, column=2, padx=5)

boton_conectar_local = tk.Button(frame_local_conexion, text="Conectar", command=conectar_serial)
boton_conectar_local.grid(row=0, column=3, padx=5)

boton_desconectar_local = tk.Button(frame_local_conexion, text="Desconectar", state="disabled", command=desconectar_serial)
boton_desconectar_local.grid(row=0, column=4, padx=5)

# Env√≠o de comandos
frame_envio = tk.Frame(frame_local)
frame_envio.pack(fill="x", padx=10, pady=5)

entrada_envio = tk.Entry(frame_envio)
entrada_envio.pack(side="left", fill="x", expand=True, padx=5)

boton_enviar = tk.Button(frame_envio, text="Enviar", command=enviar_comando)
boton_enviar.pack(side="left", padx=5)

# Caja de texto para mostrar datos
frame_local_texto = tk.Frame(frame_local)
frame_local_texto.pack(fill="both", expand=True, padx=10, pady=10)

caja_texto_local = tk.Text(frame_local_texto, wrap="none")
caja_texto_local.pack(side="left", fill="both", expand=True)

scroll_texto_local = tk.Scrollbar(frame_local_texto, command=caja_texto_local.yview)
scroll_texto_local.pack(side="right", fill="y")
caja_texto_local.config(yscrollcommand=scroll_texto_local.set)

# ----------------------------------------
# PESTA√ëA 2: Monitor Remoto (ESP32)
# (A√∫n sin cambios - se har√° en Parte 3)
# ----------------------------------------

frame_remoto = tk.Frame(notebook)
notebook.add(frame_remoto, text="Monitor Remoto (ESP32)")

etiqueta_remoto_titulo = tk.Label(frame_remoto, text="Monitoreo Remoto - ESP32 (HTTP)", font=("Arial", 16))
etiqueta_remoto_titulo.pack(pady=10)

# ----------------------------------------
# Iniciar ventana
# ----------------------------------------

ventana.mainloop()
```

---

---

# ‚úÖ PUNTOS CLAVE CUBIERTOS:

| ‚úÖ  | Descripci√≥n                                   |
| -- | --------------------------------------------- |
| ‚úîÔ∏è | Detectar puertos y mostrarlos autom√°ticamente |
| ‚úîÔ∏è | Conectar/desconectar al puerto                |
| ‚úîÔ∏è | Leer datos continuamente y mostrar en GUI     |
| ‚úîÔ∏è | Auto-scroll para ver √∫ltimos datos            |
| ‚úîÔ∏è | Enviar comandos desde la GUI al Arduino       |
| ‚úîÔ∏è | Guardar cada lectura en MySQL                 |

---

## üîß SOBRE LA BASE DE DATOS (MySQL):

deber√°n **crear previamente la base de datos** y la tabla con algo as√≠:

```sql
CREATE DATABASE monitor;

USE monitor;

CREATE TABLE lecturas_locales (
    id INT AUTO_INCREMENT PRIMARY KEY,
    fecha_hora DATETIME,
    dato VARCHAR(255)
);
```

---
